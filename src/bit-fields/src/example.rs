// Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

extern crate self as bit_fields;
/// Generated by:
/// ```ignore
/// bit_fields::bitfield!(ExampleBitField,u32,{
///     /// RANGE1 bit field
///     RANGE1: 0..1,
///     /// SSE bit flag
///     SSE: 2,
///     /// SSE1 bit flag
///     SSE1: 3,
///     /// RANGE2 bit field
///     RANGE2: 4..6,
///     /// SSE2 bit flag
///     SSE2: 9,
///     /// SSE3 bit flag
///     SSE3: 10,
///     /// RANGE3 bit field
///     RANGE3: 12..15,
///     /// SSE4 bit flag
///     SSE4: 18,
/// });
/// ```
/// Everything below this line was generated.
///
/// ---
///
/// A 32 bit structure containing a number of bit flags and bit fields.
///
/// ## Layout
///
/// <table>
///     <tr><th>Bit/s</th><th>Identifier</th><th>Description</th></tr>
///     <tr><td>00..01</td><td>RANGE1</td><td>RANGE1 bit field </td></tr>
///     <tr><td>02</td><td>SSE</td><td>SSE bit flag </td></tr>
///     <tr><td>03</td><td>SSE1</td><td>SSE1 bit flag </td></tr>
///     <tr><td>04..06</td><td>RANGE2</td><td>RANGE2 bit field </td></tr>
///     <tr><td>09</td><td>SSE2</td><td>SSE2 bit flag </td></tr>
///     <tr><td>10</td><td>SSE3</td><td>SSE3 bit flag </td></tr>
///     <tr><td>12..15</td><td>RANGE3</td><td>RANGE3 bit field </td></tr>
///     <tr><td>18</td><td>SSE4</td><td>SSE4 bit flag </td></tr>
/// </table>
#[derive(Clone)]
#[repr(C)]
pub struct ExampleBitField {
    pub data: u32,
    pub bits: (
        bit_fields::Bit<u32, 0u8>,
        bit_fields::Bit<u32, 1u8>,
        bit_fields::Bit<u32, 2u8>,
        bit_fields::Bit<u32, 3u8>,
        bit_fields::Bit<u32, 4u8>,
        bit_fields::Bit<u32, 5u8>,
        bit_fields::Bit<u32, 6u8>,
        bit_fields::Bit<u32, 7u8>,
        bit_fields::Bit<u32, 8u8>,
        bit_fields::Bit<u32, 9u8>,
        bit_fields::Bit<u32, 10u8>,
        bit_fields::Bit<u32, 11u8>,
        bit_fields::Bit<u32, 12u8>,
        bit_fields::Bit<u32, 13u8>,
        bit_fields::Bit<u32, 14u8>,
        bit_fields::Bit<u32, 15u8>,
        bit_fields::Bit<u32, 16u8>,
        bit_fields::Bit<u32, 17u8>,
        bit_fields::Bit<u32, 18u8>,
        bit_fields::Bit<u32, 19u8>,
        bit_fields::Bit<u32, 20u8>,
        bit_fields::Bit<u32, 21u8>,
        bit_fields::Bit<u32, 22u8>,
        bit_fields::Bit<u32, 23u8>,
        bit_fields::Bit<u32, 24u8>,
        bit_fields::Bit<u32, 25u8>,
        bit_fields::Bit<u32, 26u8>,
        bit_fields::Bit<u32, 27u8>,
        bit_fields::Bit<u32, 28u8>,
        bit_fields::Bit<u32, 29u8>,
        bit_fields::Bit<u32, 30u8>,
        bit_fields::Bit<u32, 31u8>,
    ),
    /// RANGE1 bit field
    pub RANGE1: bit_fields::BitRange<u32, 0u8, 1u8>,
    /// SSE bit flag
    pub SSE: bit_fields::Bit<u32, 2u8>,
    /// SSE1 bit flag
    pub SSE1: bit_fields::Bit<u32, 3u8>,
    /// RANGE2 bit field
    pub RANGE2: bit_fields::BitRange<u32, 4u8, 6u8>,
    /// SSE2 bit flag
    pub SSE2: bit_fields::Bit<u32, 9u8>,
    /// SSE3 bit flag
    pub SSE3: bit_fields::Bit<u32, 10u8>,
    /// RANGE3 bit field
    pub RANGE3: bit_fields::BitRange<u32, 12u8, 15u8>,
    /// SSE4 bit flag
    pub SSE4: bit_fields::Bit<u32, 18u8>,
}
impl serde::Serialize for ExampleBitField {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::{Serialize, SerializeMap, SerializeSeq, SerializeTuple, Serializer};
        let (set, map): (
            std::collections::HashSet<String>,
            std::collections::HashMap<String, u32>,
        ) = self.into();
        let mut tup = serializer.serialize_tuple(2)?;
        tup.serialize_element(&set)?;
        tup.serialize_element(&map)?;
        tup.end()
    }
}
struct ExampleBitFieldVisitor;
impl<'de> serde::de::Visitor<'de> for ExampleBitFieldVisitor {
    type Value = ExampleBitField;
    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            formatter,
            "a set of feature flags followed by a map of fields"
        )
    }
    fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
    where
        A: serde::de::SeqAccess<'de>,
    {
        if let Some(set) = seq.next_element::<std::collections::HashSet<String>>()? {
            if let Some(map) = seq.next_element::<std::collections::HashMap<String, u32>>()? {
                Ok(ExampleBitField::try_from((set, map))
                    .expect("Failed to deserialize #struct_name"))
            } else {
                Err(serde::de::Error::custom("no 2nd value in seq"))
            }
        } else {
            Err(serde::de::Error::custom("no 1st value in seq"))
        }
    }
}
impl<'de> serde::Deserialize<'de> for ExampleBitField {
    fn deserialize<D>(deserializer: D) -> Result<ExampleBitField, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_tuple(2, ExampleBitFieldVisitor)
    }
}
impl std::cmp::PartialEq<u32> for ExampleBitField {
    fn eq(&self, other: &u32) -> bool {
        self.data == *other
    }
}
impl std::cmp::PartialEq for ExampleBitField {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl std::cmp::Eq for ExampleBitField {}
/// We cannot derive [`std::fmt::Debug`] as `self.bits` may have too many elements.
impl std::fmt::Debug for ExampleBitField {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_tuple("ExampleBitField").field(&self.data).finish()
    }
}
impl std::fmt::Display for ExampleBitField {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!
        (f,
        "┌───────┬────────────┬───────┬───────┬────────────┬───────┬───────┬────────────┬───────┐\n│ \u{1b}[1mBit/s\u{1b}[0m │   00..01 │    02 │    03 │   04..06 │    09 │    10 │   12..15 │    18 │\n├───────┼────────────┼───────┼───────┼────────────┼───────┼───────┼────────────┼───────┤\n│ \u{1b}[1mDesc\u{1b}[0m  │     RANGE1 │   SSE │  SSE1 │     RANGE2 │  SSE2 │  SSE3 │     RANGE3 │  SSE4 │\n├───────┼────────────┼───────┼───────┼────────────┼───────┼───────┼────────────┼───────┤\n│ \u{1b}[1mValue\u{1b}[0m │ {:>10} │ {:>5} │ {:>5} │ {:>10} │ {:>5} │ {:>5} │ {:>10} │ {:>5} │\n└───────┴────────────┴───────┴───────┴────────────┴───────┴───────┴────────────┴───────┘\n",
        self.RANGE1.to_string(), self.SSE.to_string(), self.SSE1.to_string(),
        self.RANGE2.to_string(), self.SSE2.to_string(), self.SSE3.to_string(),
        self.RANGE3.to_string(), self.SSE4.to_string(),)
    }
}
/// We cannot derive [`std::default::Default`] as `self.bits` may have too many elements.
impl std::default::Default for ExampleBitField {
    fn default() -> Self {
        Self::from(0)
    }
}
impl std::fmt::Binary for ExampleBitField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Binary::fmt(&self.data, f)
    }
}
impl<T: std::fmt::Display> std::convert::TryFrom<std::collections::HashSet<T>> for ExampleBitField {
    type Error = bit_fields::TryFromFlagSetError;
    fn try_from(set: std::collections::HashSet<T>) -> Result<Self, Self::Error> {
        let mut base = Self::from(0);
        for key in set.into_iter() {
            match key.to_string().as_str() {
                "SSE" => {
                    base.SSE.on();
                }
                "SSE1" => {
                    base.SSE1.on();
                }
                "SSE2" => {
                    base.SSE2.on();
                }
                "SSE3" => {
                    base.SSE3.on();
                }
                "SSE4" => {
                    base.SSE4.on();
                }
                _ => return Err(bit_fields::TryFromFlagSetError),
            }
        }
        Ok(base)
    }
}
impl std::convert::From<&ExampleBitField> for std::collections::HashSet<String> {
    fn from(bit_field: &ExampleBitField) -> Self {
        let mut set = Self::new();
        if bit_field.SSE == true {
            set.insert(String::from("SSE"));
        }
        if bit_field.SSE1 == true {
            set.insert(String::from("SSE1"));
        }
        if bit_field.SSE2 == true {
            set.insert(String::from("SSE2"));
        }
        if bit_field.SSE3 == true {
            set.insert(String::from("SSE3"));
        }
        if bit_field.SSE4 == true {
            set.insert(String::from("SSE4"));
        }
        set
    }
}
impl<T: std::fmt::Display> std::convert::TryFrom<std::collections::HashMap<T, u32>>
    for ExampleBitField
{
    type Error = bit_fields::TryFromFieldMapError;
    fn try_from(set: std::collections::HashMap<T, u32>) -> Result<Self, Self::Error> {
        let mut base = Self::from(0);
        for (key, value) in set.into_iter() {
            match key.to_string().as_str() {
                "RANGE1" => {
                    base.RANGE1.checked_assign(value)?;
                }
                "RANGE2" => {
                    base.RANGE2.checked_assign(value)?;
                }
                "RANGE3" => {
                    base.RANGE3.checked_assign(value)?;
                }
                _ => return Err(bit_fields::TryFromFieldMapError::UnknownField),
            }
        }
        Ok(base)
    }
}
impl std::convert::From<&ExampleBitField> for std::collections::HashMap<String, u32> {
    fn from(bit_field: &ExampleBitField) -> Self {
        let mut map = Self::new();
        map.insert(String::from("RANGE1"), u32::from(&bit_field.RANGE1));
        map.insert(String::from("RANGE2"), u32::from(&bit_field.RANGE2));
        map.insert(String::from("RANGE3"), u32::from(&bit_field.RANGE3));
        map
    }
}
impl<T: std::fmt::Display>
    std::convert::TryFrom<(
        std::collections::HashSet<T>,
        std::collections::HashMap<T, u32>,
    )> for ExampleBitField
{
    type Error = bit_fields::TryFromFlagSetAndFieldMapError;
    fn try_from(
        (set, map): (
            std::collections::HashSet<T>,
            std::collections::HashMap<T, u32>,
        ),
    ) -> Result<Self, Self::Error> {
        let mut base = Self::from(0);
        for key in set.into_iter() {
            match key.to_string().as_str() {
                "SSE" => {
                    base.SSE.on();
                }
                "SSE1" => {
                    base.SSE1.on();
                }
                "SSE2" => {
                    base.SSE2.on();
                }
                "SSE3" => {
                    base.SSE3.on();
                }
                "SSE4" => {
                    base.SSE4.on();
                }
                _ => {
                    return Err(bit_fields::TryFromFlagSetAndFieldMapError::FlagSet(
                        bit_fields::TryFromFlagSetError,
                    ))
                }
            }
        }
        for (key, value) in map.into_iter() {
            match key.to_string().as_str() {
                "RANGE1" => {
                    base.RANGE1.checked_assign(value)?;
                }
                "RANGE2" => {
                    base.RANGE2.checked_assign(value)?;
                }
                "RANGE3" => {
                    base.RANGE3.checked_assign(value)?;
                }
                _ => {
                    return Err(bit_fields::TryFromFlagSetAndFieldMapError::FieldMap(
                        bit_fields::TryFromFieldMapError::UnknownField,
                    ))
                }
            }
        }
        Ok(base)
    }
}
impl std::convert::From<&ExampleBitField>
    for (
        std::collections::HashSet<String>,
        std::collections::HashMap<String, u32>,
    )
{
    fn from(bit_field: &ExampleBitField) -> Self {
        let mut set = std::collections::HashSet::<String>::new();
        if bit_field.SSE == true {
            set.insert(String::from("SSE"));
        }
        if bit_field.SSE1 == true {
            set.insert(String::from("SSE1"));
        }
        if bit_field.SSE2 == true {
            set.insert(String::from("SSE2"));
        }
        if bit_field.SSE3 == true {
            set.insert(String::from("SSE3"));
        }
        if bit_field.SSE4 == true {
            set.insert(String::from("SSE4"));
        }
        let mut map = std::collections::HashMap::<String, u32>::new();
        map.insert(String::from("RANGE1"), u32::from(&bit_field.RANGE1));
        map.insert(String::from("RANGE2"), u32::from(&bit_field.RANGE2));
        map.insert(String::from("RANGE3"), u32::from(&bit_field.RANGE3));
        (set, map)
    }
}
/// Constructs `self` with the data type.
impl std::convert::From<u32> for ExampleBitField {
    fn from(data: u32) -> Self {
        Self {
            data,
            bits: (
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
            ),
            RANGE1: bit_fields::BitRange(std::marker::PhantomData),
            SSE: bit_fields::Bit(std::marker::PhantomData),
            SSE1: bit_fields::Bit(std::marker::PhantomData),
            RANGE2: bit_fields::BitRange(std::marker::PhantomData),
            SSE2: bit_fields::Bit(std::marker::PhantomData),
            SSE3: bit_fields::Bit(std::marker::PhantomData),
            RANGE3: bit_fields::BitRange(std::marker::PhantomData),
            SSE4: bit_fields::Bit(std::marker::PhantomData),
        }
    }
}
/// Constructs the data type from `self`.
impl std::convert::From<ExampleBitField> for u32 {
    fn from(bit_field: ExampleBitField) -> Self {
        bit_field.data
    }
}
impl ExampleBitField {
    const fn new(data: u32) -> Self {
        Self {
            data,
            bits: (
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
                bit_fields::Bit(std::marker::PhantomData),
            ),
            RANGE1: bit_fields::BitRange(std::marker::PhantomData),
            SSE: bit_fields::Bit(std::marker::PhantomData),
            SSE1: bit_fields::Bit(std::marker::PhantomData),
            RANGE2: bit_fields::BitRange(std::marker::PhantomData),
            SSE2: bit_fields::Bit(std::marker::PhantomData),
            SSE3: bit_fields::Bit(std::marker::PhantomData),
            RANGE3: bit_fields::BitRange(std::marker::PhantomData),
            SSE4: bit_fields::Bit(std::marker::PhantomData),
        }
    }
    /// Returns [`std::cmp::Ordering`] based on bit flags.
    /// - `Some(Ordering::Equal)` - Bit flags match between `self` and `other`.
    /// - `Some(Ordering::Greater)` - Bit flags of `self` are a strict superset of bit flags of
    ///   `other`.
    /// - `Some(Ordering::Less)` - Bit flags of `self` are a strict subset of bit flags of `other`.
    /// - `None` - None of the above conditions are met.
    pub fn cmp_flags(&self, other: &Self) -> Option<std::cmp::Ordering> {
        if self == other {
            Some(std::cmp::Ordering::Equal)
        } else if self.superset(other) {
            Some(std::cmp::Ordering::Greater)
        } else if self.subset(other) {
            Some(std::cmp::Ordering::Less)
        } else {
            None
        }
    }
    /// Returns `true` if `self` is a [`superset`](https://en.wikipedia.org/wiki/Subset) of `other`.
    pub fn superset(&self, other: &Self) -> bool {
        true && if other.SSE == true {
            bool::from(&self.SSE)
        } else {
            true
        } && if other.SSE1 == true {
            bool::from(&self.SSE1)
        } else {
            true
        } && if other.SSE2 == true {
            bool::from(&self.SSE2)
        } else {
            true
        } && if other.SSE3 == true {
            bool::from(&self.SSE3)
        } else {
            true
        } && if other.SSE4 == true {
            bool::from(&self.SSE4)
        } else {
            true
        }
    }
    /// Returns `true` if `self` is a [`subset`](https://en.wikipedia.org/wiki/Subset) of `other`.
    pub fn subset(&self, other: &Self) -> bool {
        true && if self.SSE == true {
            bool::from(&other.SSE)
        } else {
            true
        } && if self.SSE1 == true {
            bool::from(&other.SSE1)
        } else {
            true
        } && if self.SSE2 == true {
            bool::from(&other.SSE2)
        } else {
            true
        } && if self.SSE3 == true {
            bool::from(&other.SSE3)
        } else {
            true
        } && if self.SSE4 == true {
            bool::from(&other.SSE4)
        } else {
            true
        }
    }
    /// Returns `true` if `self` and `other` are [`disjoint sets`](https://en.wikipedia.org/wiki/Disjoint_sets).
    pub fn disjoint(&self, other: &Self) -> bool {
        false
            || !(self.SSE == other.SSE)
            || !(self.SSE1 == other.SSE1)
            || !(self.SSE2 == other.SSE2)
            || !(self.SSE3 == other.SSE3)
            || !(self.SSE4 == other.SSE4)
    }
    /// Returns the [`intersection`](https://en.wikipedia.org/wiki/Intersection_(set_theory)) of `self` and `other`.
    pub fn intersection(&self, other: &Self) -> Self {
        let mut base = Self::from(0);
        if self.SSE == true && other.SSE == true {
            base.SSE.on();
        }
        if self.SSE1 == true && other.SSE1 == true {
            base.SSE1.on();
        }
        if self.SSE2 == true && other.SSE2 == true {
            base.SSE2.on();
        }
        if self.SSE3 == true && other.SSE3 == true {
            base.SSE3.on();
        }
        if self.SSE4 == true && other.SSE4 == true {
            base.SSE4.on();
        }
        base
    }
    /// Returns the [`union`](https://en.wikipedia.org/wiki/Union_(set_theory)) of `self` and `other`.
    pub fn union(&self, other: &Self) -> Self {
        let mut base = Self::from(0);
        if self.SSE == true || other.SSE == true {
            base.SSE.on();
        }
        if self.SSE1 == true || other.SSE1 == true {
            base.SSE1.on();
        }
        if self.SSE2 == true || other.SSE2 == true {
            base.SSE2.on();
        }
        if self.SSE3 == true || other.SSE3 == true {
            base.SSE3.on();
        }
        if self.SSE4 == true || other.SSE4 == true {
            base.SSE4.on();
        }
        base
    }
    /// Returns a reference to the `N`th bit.
    pub fn bit<const N: u8>(&self) -> &bit_fields::Bit<u32, N>
    where
        Self: bit_fields::BitIndex<u32, N>,
    {
        <Self as bit_fields::BitIndex<u32, N>>::bit(self)
    }
    /// Returns a mutable reference to the `N`th bit.
    pub fn bit_mut<const N: u8>(&mut self) -> &mut bit_fields::Bit<u32, N>
    where
        Self: bit_fields::BitIndexMut<u32, N>,
    {
        <Self as bit_fields::BitIndexMut<u32, N>>::bit_mut(self)
    }
}
impl bit_fields::BitIndex<u32, 0> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 0> {
        &self.bits.0
    }
}
impl bit_fields::BitIndexMut<u32, 0> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 0> {
        &mut self.bits.0
    }
}
impl bit_fields::BitIndex<u32, 1> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 1> {
        &self.bits.1
    }
}
impl bit_fields::BitIndexMut<u32, 1> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 1> {
        &mut self.bits.1
    }
}
impl bit_fields::BitIndex<u32, 2> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 2> {
        &self.bits.2
    }
}
impl bit_fields::BitIndexMut<u32, 2> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 2> {
        &mut self.bits.2
    }
}
impl bit_fields::BitIndex<u32, 3> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 3> {
        &self.bits.3
    }
}
impl bit_fields::BitIndexMut<u32, 3> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 3> {
        &mut self.bits.3
    }
}
impl bit_fields::BitIndex<u32, 4> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 4> {
        &self.bits.4
    }
}
impl bit_fields::BitIndexMut<u32, 4> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 4> {
        &mut self.bits.4
    }
}
impl bit_fields::BitIndex<u32, 5> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 5> {
        &self.bits.5
    }
}
impl bit_fields::BitIndexMut<u32, 5> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 5> {
        &mut self.bits.5
    }
}
impl bit_fields::BitIndex<u32, 6> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 6> {
        &self.bits.6
    }
}
impl bit_fields::BitIndexMut<u32, 6> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 6> {
        &mut self.bits.6
    }
}
impl bit_fields::BitIndex<u32, 7> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 7> {
        &self.bits.7
    }
}
impl bit_fields::BitIndexMut<u32, 7> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 7> {
        &mut self.bits.7
    }
}
impl bit_fields::BitIndex<u32, 8> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 8> {
        &self.bits.8
    }
}
impl bit_fields::BitIndexMut<u32, 8> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 8> {
        &mut self.bits.8
    }
}
impl bit_fields::BitIndex<u32, 9> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 9> {
        &self.bits.9
    }
}
impl bit_fields::BitIndexMut<u32, 9> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 9> {
        &mut self.bits.9
    }
}
impl bit_fields::BitIndex<u32, 10> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 10> {
        &self.bits.10
    }
}
impl bit_fields::BitIndexMut<u32, 10> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 10> {
        &mut self.bits.10
    }
}
impl bit_fields::BitIndex<u32, 11> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 11> {
        &self.bits.11
    }
}
impl bit_fields::BitIndexMut<u32, 11> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 11> {
        &mut self.bits.11
    }
}
impl bit_fields::BitIndex<u32, 12> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 12> {
        &self.bits.12
    }
}
impl bit_fields::BitIndexMut<u32, 12> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 12> {
        &mut self.bits.12
    }
}
impl bit_fields::BitIndex<u32, 13> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 13> {
        &self.bits.13
    }
}
impl bit_fields::BitIndexMut<u32, 13> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 13> {
        &mut self.bits.13
    }
}
impl bit_fields::BitIndex<u32, 14> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 14> {
        &self.bits.14
    }
}
impl bit_fields::BitIndexMut<u32, 14> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 14> {
        &mut self.bits.14
    }
}
impl bit_fields::BitIndex<u32, 15> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 15> {
        &self.bits.15
    }
}
impl bit_fields::BitIndexMut<u32, 15> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 15> {
        &mut self.bits.15
    }
}
impl bit_fields::BitIndex<u32, 16> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 16> {
        &self.bits.16
    }
}
impl bit_fields::BitIndexMut<u32, 16> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 16> {
        &mut self.bits.16
    }
}
impl bit_fields::BitIndex<u32, 17> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 17> {
        &self.bits.17
    }
}
impl bit_fields::BitIndexMut<u32, 17> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 17> {
        &mut self.bits.17
    }
}
impl bit_fields::BitIndex<u32, 18> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 18> {
        &self.bits.18
    }
}
impl bit_fields::BitIndexMut<u32, 18> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 18> {
        &mut self.bits.18
    }
}
impl bit_fields::BitIndex<u32, 19> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 19> {
        &self.bits.19
    }
}
impl bit_fields::BitIndexMut<u32, 19> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 19> {
        &mut self.bits.19
    }
}
impl bit_fields::BitIndex<u32, 20> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 20> {
        &self.bits.20
    }
}
impl bit_fields::BitIndexMut<u32, 20> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 20> {
        &mut self.bits.20
    }
}
impl bit_fields::BitIndex<u32, 21> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 21> {
        &self.bits.21
    }
}
impl bit_fields::BitIndexMut<u32, 21> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 21> {
        &mut self.bits.21
    }
}
impl bit_fields::BitIndex<u32, 22> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 22> {
        &self.bits.22
    }
}
impl bit_fields::BitIndexMut<u32, 22> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 22> {
        &mut self.bits.22
    }
}
impl bit_fields::BitIndex<u32, 23> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 23> {
        &self.bits.23
    }
}
impl bit_fields::BitIndexMut<u32, 23> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 23> {
        &mut self.bits.23
    }
}
impl bit_fields::BitIndex<u32, 24> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 24> {
        &self.bits.24
    }
}
impl bit_fields::BitIndexMut<u32, 24> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 24> {
        &mut self.bits.24
    }
}
impl bit_fields::BitIndex<u32, 25> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 25> {
        &self.bits.25
    }
}
impl bit_fields::BitIndexMut<u32, 25> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 25> {
        &mut self.bits.25
    }
}
impl bit_fields::BitIndex<u32, 26> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 26> {
        &self.bits.26
    }
}
impl bit_fields::BitIndexMut<u32, 26> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 26> {
        &mut self.bits.26
    }
}
impl bit_fields::BitIndex<u32, 27> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 27> {
        &self.bits.27
    }
}
impl bit_fields::BitIndexMut<u32, 27> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 27> {
        &mut self.bits.27
    }
}
impl bit_fields::BitIndex<u32, 28> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 28> {
        &self.bits.28
    }
}
impl bit_fields::BitIndexMut<u32, 28> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 28> {
        &mut self.bits.28
    }
}
impl bit_fields::BitIndex<u32, 29> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 29> {
        &self.bits.29
    }
}
impl bit_fields::BitIndexMut<u32, 29> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 29> {
        &mut self.bits.29
    }
}
impl bit_fields::BitIndex<u32, 30> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 30> {
        &self.bits.30
    }
}
impl bit_fields::BitIndexMut<u32, 30> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 30> {
        &mut self.bits.30
    }
}
impl bit_fields::BitIndex<u32, 31> for ExampleBitField {
    fn bit(&self) -> &bit_fields::Bit<u32, 31> {
        &self.bits.31
    }
}
impl bit_fields::BitIndexMut<u32, 31> for ExampleBitField {
    fn bit_mut(&mut self) -> &mut bit_fields::Bit<u32, 31> {
        &mut self.bits.31
    }
}
